/*
 * Copyright (c) godot-rust; Bromeon and contributors.
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

use proc_macro2::{Ident, Span, TokenStream};
use quote::{format_ident, quote, quote_spanned, ToTokens};
use venial::TypeExpr;

use crate::class::{
    into_signature_info, make_accessor_type_check, make_method_registration, Field, FieldHint,
    FuncDefinition,
};
use crate::util::{ident, make_funcs_collection_constant, KvParser};
use crate::{util, ParseResult};

/// Store info from `#[var]` attribute.
#[derive(Clone, Debug)]
pub struct FieldVar {
    /// What name this variable should have in Godot, if `None` then the Rust name should be used.
    pub rename: Option<Ident>,
    pub getter: GetterSetter,
    pub setter: GetterSetter,
    pub hint: FieldHint,
    pub usage_flags: UsageFlags,
    /// Whether generated getters/setters should be exposed in Rust public API (without deprecation warning).
    pub rust_public: bool,
    pub span: Span,
}

impl FieldVar {
    /// Parse a `#[var]` attribute to a `FieldVar` struct.
    ///
    /// Possible keys:
    /// - `rename = ident`
    /// - `get`, `get = expr`, `no_get`
    /// - `set`, `set = expr`, `no_set`
    /// - `pub`
    /// - `hint = ident`
    /// - `hint_string = expr`
    /// - `usage_flags = [...]`
    pub(crate) fn new_from_kv(parser: &mut KvParser) -> ParseResult<Self> {
        let span = parser.span();
        let rename = parser.handle_ident("rename")?;
        let getter = GetterSetter::parse(parser, "get")?;
        let setter = GetterSetter::parse(parser, "set")?;
        let rust_public = parser.handle_alone("pub")?;

        // Validate: `pub` only makes sense if at least one accessor is generated.
        if rust_public && getter != GetterSetter::Generated && setter != GetterSetter::Generated {
            return Err(util::error!(
                span,
                "`pub` requires at least one generated accessor; both getter and setter are user-defined or disabled"
            ));
        }

        let hint = parser.handle_ident("hint")?;

        let hint = if let Some(hint) = hint {
            let hint_string = parser.handle_expr("hint_string")?;

            FieldHint::new(hint, hint_string)
        } else {
            FieldHint::Inferred
        };

        let usage_flags = if let Some(mut parser) = parser.handle_array("usage_flags")? {
            let mut flags = Vec::new();

            while let Some(flag) = parser.next_ident()? {
                flags.push(flag)
            }

            parser.finish()?;

            UsageFlags::Custom(flags)
        } else {
            UsageFlags::Inferred
        };

        Ok(FieldVar {
            rename,
            getter,
            setter,
            hint,
            usage_flags,
            rust_public,
            span,
        })
    }

    pub(crate) fn new_tool_button_from_kv(parser: &mut KvParser) -> ParseResult<Self> {
        let span = parser.span();

        let hint_string = {
            let Some(name) = parser.handle_literal("name", "String")? else {
                return Err(util::error!(
                    span,
                    "`#[export_tool_button]` requires `name attribute.\n \
                Tip: use `#[export_tool_button(name=\" ... \")]`"
                ));
            };

            if let Some(icon) = parser.handle_literal("icon", "String")? {
                let hint_string = format!(
                    "{},{}",
                    name.to_string().trim_matches('\"'),
                    icon.to_string().trim_matches('\"')
                );
                hint_string.to_token_stream()
            } else {
                name.to_token_stream()
            }
        };

        let recv = if let Some(static_func) = parser.handle_expr("fn")? {
            ToolButtonType::Static(static_func)
        } else if let Some(fn_self) = parser.handle_expr("fn_self")? {
            ToolButtonType::Mut(fn_self)
        } else if let Some(method_name) = parser.handle_literal("method", "String")? {
            ToolButtonType::Method(method_name.to_token_stream())
        } else {
            // Autogenerated - user will provide valid Callable by themselves.
            ToolButtonType::Var
        };

        let hint = FieldHint::new(ident("TOOL_BUTTON"), Some(hint_string));
        Ok(FieldVar {
            rename: None,
            getter: GetterSetter::ToolButton(recv),
            setter: GetterSetter::Generated,
            hint,
            usage_flags: UsageFlags::Custom(vec![ident("EDITOR")]),
            rust_public: true,
            span,
        })
    }
}

impl Default for FieldVar {
    fn default() -> Self {
        Self {
            rename: Default::default(),
            getter: Default::default(),
            setter: Default::default(),
            hint: Default::default(),
            usage_flags: Default::default(),
            rust_public: false,
            span: Span::call_site(),
        }
    }
}

#[derive(Default, Clone, Debug)]
pub enum ToolButtonType {
    /// Same as `#[var]`: Trivial getter/setter should be autogenerated.
    #[default]
    Var,
    Mut(TokenStream),
    Static(TokenStream),
    Method(TokenStream),
}

impl Eq for ToolButtonType {}

impl PartialEq for ToolButtonType {
    fn eq(&self, other: &Self) -> bool {
        match (self, other) {
            (ToolButtonType::Var, ToolButtonType::Var) => true,
            (ToolButtonType::Mut(stream), ToolButtonType::Mut(other_stream))
            | (ToolButtonType::Static(stream), ToolButtonType::Static(other_stream))
            | (ToolButtonType::Method(stream), ToolButtonType::Method(other_stream)) => {
                // Same as Ident's eq, we just slap _whatever_ impl to squeeze proper traits on ToolButtonType anyway.
                stream.to_string() == other_stream.to_string()
            }
            (_, _) => false,
        }
    }
}

#[derive(Default, Clone, Eq, PartialEq, Debug)]
pub enum GetterSetter {
    /// `#[var]`: Trivial getter/setter should be autogenerated.
    #[default]
    Generated,

    /// `#[var(get)]`: Custom setter with default name.
    Custom,

    /// `#[var(get = ident)]`: Custom setter with custom name.
    CustomRenamed(Ident),

    /// `#[export_tool_button(fn = expr | fn_self = expr | method = literal)]`: Autogenerated getter for Callables.
    ToolButton(ToolButtonType),

    /// `#[var(no_get)]`: Getter/setter is absent, field is write/read only.
    Disabled,
}

impl GetterSetter {
    /// Parse a getter or setter from the attribute parser.
    pub(super) fn parse(parser: &mut KvParser, key: &str) -> ParseResult<Self> {
        // #[var(no_get)], #[var(no_set)]
        if parser.handle_alone(&format!("no_{key}"))? {
            return Ok(GetterSetter::Disabled);
        }

        let getter_setter = match parser.handle_any(key) {
            // No `get` key.
            None => GetterSetter::Generated,
            Some(value) => match value {
                // `get` without value: user-defined impl, but default name.
                None => GetterSetter::Custom,
                // `get = expr`
                Some(value) => GetterSetter::CustomRenamed(value.ident()?),
            },
        };

        Ok(getter_setter)
    }

    /// Returns the name, implementation, and export tokens for this `GetterSetter` declaration, for the
    /// given field and getter/setter kind.
    ///
    /// Returns `None` if no getter/setter should be created.
    pub(super) fn to_impl(
        &self,
        class_name: &Ident,
        kind: GetSet,
        field: &Field,
        rename: &Option<Ident>,
        rust_public: bool,
    ) -> Option<GetterSetterImpl> {
        match self {
            GetterSetter::Disabled => None,
            GetterSetter::Generated | GetterSetter::ToolButton(ToolButtonType::Var) => {
                Some(GetterSetterImpl::from_generated_impl(
                    class_name,
                    kind,
                    field,
                    rename,
                    rust_public,
                    None,
                ))
            }
            GetterSetter::Custom => Some(GetterSetterImpl::from_custom_impl(
                class_name, kind, field, rename,
            )),
            GetterSetter::CustomRenamed(function_name) => Some(
                GetterSetterImpl::from_custom_impl_renamed(class_name, kind, field, function_name),
            ),
            GetterSetter::ToolButton(tool_button_type) => {
                Some(GetterSetterImpl::from_generated_impl(
                    class_name,
                    kind,
                    field,
                    rename,
                    rust_public,
                    Some(tool_button_type),
                ))
            }
        }
    }
}

/// Used to determine whether a [`GetterSetter`] is supposed to be a getter or setter.
#[derive(Copy, Clone, Eq, PartialEq, Debug)]
pub enum GetSet {
    Get,
    Set,
}

impl GetSet {
    /// Create the Rust name for this getter/setter. Used for `#[var(pub)]` methods.
    // TODO(v0.5): migrate `rename` -> Option<String> and propagate upwards.
    pub fn make_pub_fn_name(self, field_name: &Ident, rename: &Option<Ident>) -> Ident {
        let prefix = self.prefix();

        if let Some(rename) = rename {
            format_ident!("{prefix}{rename}", span = field_name.span())
        } else {
            format_ident!("{prefix}{field_name}", span = field_name.span())
        }
    }

    fn prefix(self) -> &'static str {
        match self {
            GetSet::Get => "get_",
            GetSet::Set => "set_",
        }
    }
}

#[derive(Clone, Debug)]
pub struct GetterSetterImpl {
    pub rust_accessor: Ident,
    pub function_impl: TokenStream,
    pub export_token: TokenStream,
    pub funcs_collection_constant: TokenStream,
}

impl GetterSetterImpl {
    fn from_generated_impl(
        class_name: &Ident,
        kind: GetSet,
        field: &Field,
        rename: &Option<Ident>,
        rust_public: bool,
        tool_button_type: Option<&ToolButtonType>,
    ) -> Self {
        let Field {
            name: field_name,
            ty: field_type,
            ..
        } = field;

        // Use field's span so errors point to the field, not the derive macro. Separate type span for trait errors, e.g.:
        //
        //   328 |     pub my_enum: TestEnum,
        //       |                  ^^^^^^^^ the trait `Clone` is not implemented for `TestEnum`
        //       |
        //       = note: required for `TestEnum` to implement `Var` (Clone bound for blanket impl)
        let field_ty_span = field_type.span();
        let field_span = field_name.span();

        // Godot-registered function name is always the user-facing name.
        let godot_function_name = kind.make_pub_fn_name(field_name, rename);

        // For #[var(pub)], use the nice name and Var::PubType (Clone-based semantics for blanket impl).
        // Otherwise, use a mangled internal name, Var::Via (GodotConvert-based semantics),
        // and generate a deprecated forwarding function.
        // TODO(v0.6): remove deprecated forwarding functions.
        let rust_accessor;
        let doc_hidden;
        let deprecated_function;
        let signature;
        let function_body;

        if let Some(tool_button_type) = tool_button_type {
            rust_accessor = godot_function_name.clone();
            doc_hidden = quote! { #[doc(hidden)] };
            deprecated_function = TokenStream::new();

            (signature, function_body) = GetterSetterImpl::generate_tool_button_impl(
                field_name,
                field_type,
                &rust_accessor,
                tool_button_type,
            );
        } else if rust_public {
            rust_accessor = godot_function_name.clone();
            doc_hidden = TokenStream::new();
            deprecated_function = TokenStream::new();

            match kind {
                GetSet::Get => {
                    signature = quote_spanned! { field_ty_span=>
                        fn #rust_accessor(&self) -> <#field_type as ::godot::register::property::Var>::PubType
                    };
                    function_body = quote_spanned! { field_ty_span=>
                        <#field_type as ::godot::register::property::Var>::var_pub_get(&self.#field_name)
                    };
                }
                GetSet::Set => {
                    signature = quote_spanned! { field_ty_span=>
                        fn #rust_accessor(&mut self, #field_name: <#field_type as ::godot::register::property::Var>::PubType)
                    };
                    function_body = quote_spanned! { field_ty_span=>
                        <#field_type as ::godot::register::property::Var>::var_pub_set(&mut self.#field_name, #field_name)
                    };
                }
            }
        } else {
            let prefix = kind.prefix();
            rust_accessor = format_ident!("__godot_{prefix}{field_name}", span = field_span);
            doc_hidden = quote! { #[doc(hidden)] };

            let deprecated_fn = match kind {
                GetSet::Get => quote_spanned! { field_ty_span=>
                    pub fn #godot_function_name(&self) -> <#field_type as ::godot::meta::GodotConvert>::Via {
                        self.#rust_accessor()
                    }
                },
                GetSet::Set => quote_spanned! { field_ty_span=>
                    pub fn #godot_function_name(&mut self, #field_name: <#field_type as ::godot::meta::GodotConvert>::Via) {
                        self.#rust_accessor(#field_name)
                    }
                },
            };

            deprecated_function = quote! {
                // Deprecated forwarding function with the nice name.
                #[deprecated = "Auto-generated Rust getters/setters for `#[var]` are being phased out until v0.6.\n\
                    If you need them, opt in with #[var(pub)]."]
                #[allow(dead_code)] // These functions are not used for registration; pub fns in private modules remain unused.
                #deprecated_fn
            };

            match kind {
                GetSet::Get => {
                    signature = quote_spanned! { field_ty_span=>
                        fn #rust_accessor(&self) -> <#field_type as ::godot::meta::GodotConvert>::Via
                    };
                    function_body = quote_spanned! { field_ty_span=>
                        <#field_type as ::godot::register::property::Var>::var_get(&self.#field_name)
                    };
                }
                GetSet::Set => {
                    signature = quote_spanned! { field_ty_span=>
                        fn #rust_accessor(&mut self, #field_name: <#field_type as ::godot::meta::GodotConvert>::Via)
                    };
                    function_body = quote_spanned! { field_ty_span=>
                        <#field_type as ::godot::register::property::Var>::var_set(&mut self.#field_name, #field_name)
                    };
                }
            }
        }

        // Assign all tokens to field's span. Supposed to help IDE navigation (get_foo -> foo field), but did not work out in testing.
        // The function names already have the correct spans, so simple quote! might also work here.
        let function_impl = quote_spanned! { field_span=>
            #doc_hidden
            pub #signature {
                #function_body
            }
            #deprecated_function
        };

        let funcs_collection_constant = make_funcs_collection_constant(
            class_name,
            &rust_accessor,
            Some(&godot_function_name.to_string()),
            &[],
        );

        let signature = util::parse_signature(signature);
        let export_token = make_method_registration(
            class_name,
            FuncDefinition {
                signature_info: into_signature_info(signature, class_name, false),
                // Since we're analyzing a struct's field, we don't have access to the corresponding get/set function's
                // external (non-#[func]) attributes. We have to assume the function exists and has the name the user
                // gave us, with the expected signature.
                // Ideally, we'd be able to place #[cfg_attr] on #[var(get)] and #[var(set)] to be able to match a
                // #[cfg()] (for instance) placed on the getter/setter function, but that is not currently supported.
                external_attributes: Vec::new(),
                // The Rust function name may differ from the Godot name (e.g. `__godot_get_field` vs `get_field`).
                registered_name: Some(godot_function_name.to_string()),
                is_script_virtual: false,
                rpc_info: None,
            },
            None,
        );

        let export_token = export_token.expect("getter/setter generation should not fail");

        Self {
            rust_accessor,
            function_impl,
            export_token,
            funcs_collection_constant,
        }
    }

    /// Generates signature and function body for `#[export_tool_button]` getter.
    //
    // Few words of explanation:
    // In general there are three valid places to create tool button Callable â€“ `init`, `on_notification` and getter/setter.
    // `init` is tricky due to all the refcount-related headache-inducing problems.
    // `on_notification` shares the very same set of problems and makes it hard to plug-in the library code in a way which would be maintainable.
    //
    // Therefore, we resort to getters instead. Creating or recreating object sets our callable to Callable::invalid(),
    // while getter recreates said Callable if it haven't been set yet. If user overrides manual init and plugs in their own Callable,
    // we just don't recreate it (hot reload forces recreation of said Callable so it is still jazzy and sound).
    fn generate_tool_button_impl(
        field_name: &Ident,
        field_type: &TypeExpr,
        rust_accessor: &Ident,
        ty: &ToolButtonType,
    ) -> (TokenStream, TokenStream) {
        let set_callable_body;
        let field_ty_span = field_type.span();
        let callable_name = format!("tool_button_{field_name}");

        match ty {
            ToolButtonType::Mut(func) => {
                // Construct new instance using instance id.
                // Silly but avoids leaking memory in editor when working with classes inheriting RefCounted
                // while not exposing WeakRef or other utterly cursed pandora box.
                // `#[export_tool_button]` is usable only in editor, so performance shouldn't be much of an issue.
                set_callable_body = quote! {
                    let instance_id = self.base().instance_id();
                    self.#field_name = ::godot::builtin::Callable::from_linked_fn(#callable_name, &self.to_gd(), move |args| {
                        let mut obj = Gd::<Self>::from_instance_id(instance_id);
                        #func(&mut *obj.bind_mut());
                    });
                }
            }
            ToolButtonType::Static(func) => {
                set_callable_body = quote! {
                    self.#field_name = ::godot::builtin::Callable::from_fn(#callable_name, |_args| {
                        #func()
                    });
                }
            }
            ToolButtonType::Method(method) => {
                set_callable_body = quote! {
                    self.#field_name = ::godot::builtin::Callable::from_object_method(&self.to_gd(), #method);
                }
            }
            // SAFETY: Must be matched earlier and handled by `from_generated_impl`.
            ToolButtonType::Var => unsafe { std::hint::unreachable_unchecked() },
        }

        let signature = quote_spanned! { field_ty_span=>
            fn #rust_accessor(&mut self) -> <#field_type as ::godot::register::property::Var>::PubType
        };

        let function_body = quote_spanned! { field_ty_span=>
            if !self.#field_name.is_valid() {
                #set_callable_body
            }

            <#field_type as ::godot::register::property::Var>::var_pub_get(&self.#field_name)
        };

        (signature, function_body)
    }

    /// User-defined name.
    fn from_custom_impl_renamed(
        class_name: &Ident,
        kind: GetSet,
        field: &Field,
        function_name: &Ident,
    ) -> Self {
        let export_token = make_accessor_type_check(class_name, function_name, &field.ty, kind);

        Self {
            rust_accessor: function_name.clone(),
            function_impl: TokenStream::new(),
            export_token,
            funcs_collection_constant: TokenStream::new(),
        }
    }

    /// Default name for property.
    fn from_custom_impl(
        class_name: &Ident,
        kind: GetSet,
        field: &Field,
        rename: &Option<Ident>,
    ) -> Self {
        let function_name = kind.make_pub_fn_name(&field.name, rename);
        let export_token = make_accessor_type_check(class_name, &function_name, &field.ty, kind);

        Self {
            rust_accessor: function_name,
            function_impl: TokenStream::new(),
            export_token,
            funcs_collection_constant: TokenStream::new(),
        }
    }
}

#[derive(Default, Clone, Debug)]
pub enum UsageFlags {
    /// The usage flags should be inferred based on context.
    #[default]
    Inferred,

    /// The usage flags should be inferred based on context, such that they include export.
    InferredExport,

    /// Use a custom set of usage flags provided by the user.
    Custom(Vec<Ident>),
}

impl UsageFlags {
    pub fn is_inferred(&self) -> bool {
        matches!(self, Self::Inferred)
    }
}
