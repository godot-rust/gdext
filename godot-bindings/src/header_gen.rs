/*
 * Copyright (c) godot-rust; Bromeon and contributors.
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

use std::env;
use std::path::Path;

/// Target pointer width for binding generation.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum TargetPointerWidth {
    /// 32-bit target (e.g., wasm32, i686)
    Bits32,
    /// 64-bit target (e.g., x86_64, aarch64)
    Bits64,
}

impl TargetPointerWidth {
    /// Returns the clang target triple for this pointer width.
    fn clang_target(&self) -> &'static str {
        match self {
            // Use wasm32-unknown-emscripten as the 32-bit target since that's the primary
            // 32-bit platform supported by Godot/gdext.
            TargetPointerWidth::Bits32 => "wasm32-unknown-emscripten",
            TargetPointerWidth::Bits64 => "x86_64-unknown-linux-gnu",
        }
    }
}

/// Generate Rust bindings from a C header file.
///
/// This is the standard function that determines whether to enable layout tests
/// based on cross-compilation detection (host vs target pointer width).
pub(crate) fn generate_rust_binding(in_h_path: &Path, out_rs_path: &Path) {
    let c_header_path = in_h_path.display().to_string();

    // Default behavior of bindgen is to invalidate the built crate whenever any of the included header files changed. This is sensible,
    // but in our case, listening to changes on files that are generated by this build step cause an infinite loop with cargo watch of:
    //     build -> detect change -> rebuild -> detect change -> ...
    // println!("cargo:rerun-if-changed={}", c_header_path);
    //
    // Without `rerun_on_header_files(false)`, the following command causes repeated recompilation of godot-ffi onward:
    //     cargo build -p itest --features godot/api-custom
    //
    // This is non-trivial to fix and isn't planned at the moment, see https://github.com/godot-rust/gdext/issues/281.
    // If you have an idea to address this without too invasive changes, please comment on that issue.
    let cargo_cfg = bindgen::CargoCallbacks::new().rerun_on_header_files(false);

    // Only disable layout tests when cross-compiling between different pointer widths.
    // Layout tests are generated based on the host architecture but validated on the target,
    // which causes failures when cross-compiling (e.g., from 64-bit host to 32-bit target)
    // because struct sizes differ. See: https://github.com/godot-rust/gdext/issues/347.
    let host_pointer_width = std::mem::size_of::<usize>() * 8;
    let target_pointer_width: usize = env::var("CARGO_CFG_TARGET_POINTER_WIDTH")
        .ok()
        .and_then(|s| s.parse().ok())
        .unwrap_or(host_pointer_width);
    let enable_layout_tests = host_pointer_width == target_pointer_width;

    let builder = bindgen::Builder::default()
        .header(c_header_path)
        .parse_callbacks(Box::new(cargo_cfg))
        .prepend_enum_name(false)
        .layout_tests(enable_layout_tests)
        // Bindgen can generate wrong size checks for types defined as `__attribute__((aligned(__alignof__(struct {...}))))`,
        // which is how clang defines max_align_t: https://clang.llvm.org/doxygen/____stddef__max__align__t_8h_source.html.
        // Size checks seems to be fine on all the targets but `wasm32-unknown-emscripten`, disallowing web builds.
        // We don't use `max_align_t` anywhere, so blacklisting it until upstream fixes the problem seems to be the most sane solution.
        // See: https://github.com/rust-lang/rust-bindgen/issues/3295.
        .blocklist_type("max_align_t");

    std::fs::create_dir_all(
        out_rs_path
            .parent()
            .expect("bindgen output file has parent dir"),
    )
    .expect("create bindgen output dir");

    let bindings = configure_platform_specific(builder)
        .generate()
        .unwrap_or_else(|err| {
            panic!(
                "bindgen generate failed\n    c: {}\n   rs: {}\n  err: {}\n",
                in_h_path.display(),
                out_rs_path.display(),
                err
            )
        });

    // Write the bindings to the $OUT_DIR/bindings.rs file.
    bindings.write_to_file(out_rs_path).unwrap_or_else(|err| {
        panic!(
            "bindgen write failed\n    c: {}\n   rs: {}\n  err: {}\n",
            in_h_path.display(),
            out_rs_path.display(),
            err
        )
    });
}

/// Generate Rust bindings from a C header file for a specific target pointer width.
///
/// This function is intended for use by the prebuilt artifact generator (godot4-prebuilt)
/// to generate bindings for both 32-bit and 64-bit targets from a single host machine.
///
/// Unlike [`generate_rust_binding`], this function:
/// - Explicitly targets a specific pointer width via clang's `--target` flag
/// - Always enables layout tests (since the target is explicitly specified)
///
/// # Arguments
/// * `in_h_path` - Path to the input C header file
/// * `out_rs_path` - Path where the generated Rust bindings will be written
/// * `target_width` - The target pointer width to generate bindings for
pub fn generate_rust_binding_for_target(
    in_h_path: &Path,
    out_rs_path: &Path,
    target_width: TargetPointerWidth,
) {
    let c_header_path = in_h_path.display().to_string();

    // We don't need cargo rerun-if-changed since this is for prebuilt generation.
    let cargo_cfg = bindgen::CargoCallbacks::new().rerun_on_header_files(false);

    let builder = bindgen::Builder::default()
        .header(c_header_path)
        .parse_callbacks(Box::new(cargo_cfg))
        .prepend_enum_name(false)
        // Enable layout tests - they will be valid for the specified target.
        .layout_tests(true)
        // Blocklist max_align_t due to bindgen issues.
        // See: https://github.com/rust-lang/rust-bindgen/issues/3295.
        .blocklist_type("max_align_t")
        // Target the specified architecture for correct pointer sizes.
        .clang_arg(format!("--target={}", target_width.clang_target()));

    std::fs::create_dir_all(
        out_rs_path
            .parent()
            .expect("bindgen output file has parent dir"),
    )
    .expect("create bindgen output dir");

    let bindings = builder.generate().unwrap_or_else(|err| {
        panic!(
            "bindgen generate failed\n    c: {}\n   rs: {}\n  target: {:?}\n  err: {}\n",
            in_h_path.display(),
            out_rs_path.display(),
            target_width,
            err
        )
    });

    bindings.write_to_file(out_rs_path).unwrap_or_else(|err| {
        panic!(
            "bindgen write failed\n    c: {}\n   rs: {}\n  err: {}\n",
            in_h_path.display(),
            out_rs_path.display(),
            err
        )
    });
}

//#[cfg(target_os = "macos")]
fn configure_platform_specific(builder: bindgen::Builder) -> bindgen::Builder {
    // On macOS arm64 architecture, we currently get the following error. Tried using different LLVM versions.
    // Not clear if bindgen can be configured in a better way.
    //  error: linking with `cc` failed: signal: 6 (SIGABRT)
    //   = note: dyld[6080]: weak-def symbol not found '__ZnwmSt19__type_descriptor_t'weak-def symbol not found '__ZnamSt19__type_descriptor_t'

    let target_vendor = env::var("CARGO_CFG_TARGET_VENDOR").unwrap();
    if target_vendor == "apple" {
        eprintln!("Build selected for macOS.");
        let path = env::var("LLVM_PATH").expect("env var 'LLVM_PATH' not set");

        builder
            .clang_arg("-I")
            // .clang_arg(format!("{path}/include"))
            .clang_arg(apple_include_path().expect("apple include path"))
            .clang_arg("-L")
            .clang_arg(format!("{path}/lib"))
            .clang_arg("-Wl,-flat_namespace,-undefined,dynamic_lookup")
    } else {
        eprintln!("Build selected for Linux/Windows.");
        builder
    }
}

fn apple_include_path() -> Result<String, std::io::Error> {
    use std::process::Command;

    let target = std::env::var("TARGET").unwrap();
    let platform = if target.contains("apple-darwin") {
        "macosx"
    } else if target == "x86_64-apple-ios" || target == "aarch64-apple-ios-sim" {
        "iphonesimulator"
    } else if target == "aarch64-apple-ios" {
        "iphoneos"
    } else {
        panic!("not building for macOS or iOS");
    };

    // run `xcrun --sdk iphoneos --show-sdk-path`
    let output = Command::new("xcrun")
        .args(["--sdk", platform, "--show-sdk-path"])
        .output()?
        .stdout;
    let prefix = std::str::from_utf8(&output)
        .expect("invalid output from `xcrun`")
        .trim_end();

    let suffix = "usr/include";
    let directory = format!("{prefix}/{suffix}");

    Ok(directory)
}

// #[cfg(not(target_os = "macos"))]
// fn configure_platform_specific(builder: Builder) -> Builder {
//     println!("Build selected for Linux/Windows.");
//     builder
// }

/*fn rerun_if_any_changed(paths: &Vec<PathBuf>){
    for path in paths {
        println!("cargo:rerun-if-changed={}", path.display());
    }
}*/

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_target_pointer_width_clang_targets() {
        // Verify 32-bit target produces wasm32 triple (primary 32-bit target for Godot)
        assert_eq!(
            TargetPointerWidth::Bits32.clang_target(),
            "wasm32-unknown-emscripten"
        );

        // Verify 64-bit target produces x86_64 triple
        assert_eq!(
            TargetPointerWidth::Bits64.clang_target(),
            "x86_64-unknown-linux-gnu"
        );
    }

    #[test]
    fn test_target_pointer_width_equality() {
        // Test PartialEq derive
        assert_eq!(TargetPointerWidth::Bits32, TargetPointerWidth::Bits32);
        assert_eq!(TargetPointerWidth::Bits64, TargetPointerWidth::Bits64);
        assert_ne!(TargetPointerWidth::Bits32, TargetPointerWidth::Bits64);
    }

    #[test]
    fn test_target_pointer_width_clone_copy() {
        // Test Clone and Copy derives
        let width = TargetPointerWidth::Bits64;
        let cloned = width.clone();
        let copied = width; // Copy

        assert_eq!(width, cloned);
        assert_eq!(width, copied);
    }

    #[test]
    fn test_target_pointer_width_debug() {
        // Test Debug derive produces meaningful output
        let debug_32 = format!("{:?}", TargetPointerWidth::Bits32);
        let debug_64 = format!("{:?}", TargetPointerWidth::Bits64);

        assert!(debug_32.contains("Bits32") || debug_32.contains("32"));
        assert!(debug_64.contains("Bits64") || debug_64.contains("64"));
    }
}
